/**
 * 
 * 
 * 1. vue-resource 可以在Vue中实现异步请求的操作---Vue2.x之前推荐使用
 *  1) npm install vue-resource
 *  2) main.js 中引入并声明使用插件
 *  3) 组件内部调用 this.$http对象进行异步操作
 * 
 * 
 * 2. axios 可以在Vue中实现异步请求的操作---Vue2.x之后推荐使用
 *  1) npm install axios
 *  2) 在需要发送异步请求的组件中引入axios,可以调用get方法发送异步请求
 *  3) axios 可以进行二次封装, 实现请求拦截器和响应拦截器的操作
 *  4) axio.get().then().catch()
 * 
 * 3. vue-router Vue中的路由器:让构建单页面应用变得易如反掌
 * 路由可以让我们实现单页应用更加的方便,做SPA更加的舒服了
 * 
 * 路由:前端路由和后台路由
 * 前端路由: 是一种映射关系,地址--->对应着某个组件
 * 浏览器的地址栏中,路由(地址)不同,页面中的某个指定位置,显示的内容是不同的
 * 单页面应用(SPA):地址栏的地址发生变化,页面没有重新加载,但是,页面的指定位置的内容发生了变化
 * 路由器和路由的关系: 路由器是用来管理路由的
 * 路由:由地址和组件组成的
 * 路由:链接地址对应着某个组件,跳转地址,对应的组件内容就会显示出来
 * 路由链接: 就是一个a标签并且设置了href属性,产生地址
 * 路由视图: 专门负责显示这个路由链接对应的这个组件内容的
 * 路由链接: <router-link> 表示路由链接,最终在页面中生成的是a标签
 * 路由视图: <router-view> 表示路由视图,最终在页面中生成的是对应的组件内容的html标签,并展示
 * 
 * 组件的不同的叫法:
 * 普通组件和路由组件
 * 普通组件:在components目录中定义的组件,引入,注册,即可以使用了
 * 路由组件:本身也是普通组件,但是需要进行路由的注册,(路由的链接地址和当前这个普通组件,形成一种映射关系),那么此时这个普通组件就变成了路由组件,一般情况路由组件都会在pages目录中进行定义
 * 注意:router目录和pages目录包括components目录的名字都不是绝对的,将来这些目录的名字命名也会取决于你们公司
 * 
 * 
 * 通过vue-router 实现当页面应用SPA的开发,首先,先安装vue-router,并且要注册路由器,
 * 
 * 路由的使用步骤:
 * 1.router目录中的index.js中引入vue-router,需要声明使用插件及注册路由,并且把这个路由对象暴露出去
 * 2.内部注册路由
 * 3.在main.js中引入路由器对象,并注册路由器(路由器和Vue进行关联)
 * 4.pages目录中是存放路由组件的
 * 配置路由器的时候(注册路由的时候),mode属性可以设置: hash----->浏览器的地址栏中有#  ,history---->地址栏中没有#, 默认是带#
 * 5. 配置路由器的时候,可以设置路由的重定向
 *  path:'/' , // 根路径，当浏览器的地址栏中访问/路径的时候,自动的跳转到/about这个地址
 *  redirect:'/about' // 重新定向到/bout的这个地址
 * 
 * 路由也是有级别的:
 * 一级路由: /about
 * 二级路由: /about/news
 * 三级路由: /about/news/message
 * 
 * 路由传参: 路由的地址在跳转的过程中可以携带参数
 * 路由传参的方式: query的方式,params的方式
 * params方式: 在注册路由的时候,需要在路由的地址的后面使用 /:标识名 的方式 这种方式叫params的方式传参
 * 该参数可以在路由跳转成功后,在当前路由组件对象中 通过$route对象的params来获取,并使用该参数数据,(在路由链接中需要使用数据进行传参)
 * 如:
 *  注册路由:
 *  {
 *    path:'地址/:id',
 *    component:组件名字
 *  }
 *  路由链接:  <router-link to="地址/参数值"></router-link>
 * query方式: 注册路由的时候不需要进行占位,但是在路由链接中需要使用?进行分隔并传参,暂且先不演示
 *  
 * 
 * $router: 当项目使用了vue-router,并且在main.js中注册了路由器之后,路由组件的实例对象中就有了$router路由器对象
 * $route: 当组件注册成为路由组件之后,每个路由组件的实例对象中都有一个$route对象,该对象叫:路由信息对象,该路由信息对象中可以获取query的参数数据,也可以获取params的参数数据
 * 
 * 声明式路由: 通过路由链接和路由视图配合,无需通过js代码即可实现路由跳转
 * 编程式路由: 通过js代码实现路由链接的跳转,并显示对应的路由视图效果
 * 
 * 
 * 声明式路由和编程式路由中的push方法操作一样,无区别
 * push和replace的区别,push有记录,replace直接就是替换操作
 * push是有历史记录的,所以,通过back返回,都是一层一层的向原来的记录中进行返回操作
 * replace是没有历史记录的(不准确),通过back返回,一块一块的返回去的---替换的操作
 * 
 * 声明式路由(路由链接跳转默认是push方式),希望能和replace方式一样,设置replace属性即可
 * 
 * 路由传参也可以通过函数模式进行传参:可以让我们在路由组件中获取参数的时候简单一些:
 *  props: (route) => ({ id: route.params.id }) 在组件内部通过props的方式来获取这里的id参数数据
 * 
 * 
 * 路由视图的标签也可以向 路由组件中传递参数数据,需要使用props的方式来进行接收
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */