/*
项目: vue-element-admin 模版 + element-ui 组件库 +axios + vuex
项目二次开发: 思路(套路)
   开发的流程思路(后台的电商管理项目):
      1. 测试接口swagger
      2. 封装api接口函数
      3. 组件中调用api接口函数进行数据测试
      4. 组件中展示数据及实现功能(调用api接口)
    复习:前台的电商项目
      1. 测试接口postMan
      2. 封装api接口函数
      3. 封装vuex
      4. 组件中调用api接口函数进行数据测试
      5. 组件中展示数据及实现功能(调用api接口)

1. 目录的认识src目录中
  1) api目录-----api接口函数(封装)
  2）assets目录---静态资源
  3) components目录---普通组件的目录
  4) icons目录---图标的目录
  5) layout目录---整体结构布局的目录
  6) router目录---路由相关的目录
  7) store目录----vuex相关的
  8) styles目录---样式文件目录
  9) test目录---复习导入和导出的
  10) utils目录---工具对象或者是工具的函数的目录(ajax的封装,表单的验证...等等)
     request.js文件,内部做了二次封装axios的操作(设置了基础的路径,超时的时间,请求头,请求拦截器和响应拦截器)
  11) views目录(相当于pages目录)-----路由组件

2.需要对商品管理模块进行开发,内部的平台属性菜单,点击的时候报错,需要修改views目录中product目录中的prop目录名字,改为attr即可

3. 品牌管理模块
   swagger 在线测试接口的工具
   element-ui 组件库
   Button组件/Table组件/Upload组件/Pagination分页组件/Form表单组件/Input组件/Dialog对话框组件


4. 面试题(重点),谈谈你对Vue中组件之间的通信的理解
组件通信的(基本)方式:
 props,自定义事件,Pubsub,事件总线,Vuex,插槽
 props:父子组件之间进行通信, 以强制绑定数据的属性的方式来进行传递,:todos="todos" 传递的是数组 :age="age" 传递的就是属性值, :getTodo="getTodo" 传递的就是函数
 事件总线:在Vue的原型上绑定一个属性,该属性是Vue的实例对象,从而实现任意组件之间进行通信
 Vuex:集中式管理状态数据的,可以实现任意组件之间进行通信
 插槽: 普通插槽,具名插槽(命名插槽),作用域插槽
 普通插槽: <slot>标签,没有名字,此时这个插槽就是普通插槽,可以进行占位,并传递数据
 具名插槽(命名插槽):<slot name="left">标签,有名字,此时这个插槽就是具名插槽,使用的使用需要定义name属性,可以进行占位,并传递数据
 作用域曹操: <slot> 配合slot-scope或者v-slot来使用,父级组件可以在自己的组件中通过作用域插槽使用子级组件中传递过来的数据,父子组件之间通信(子父组件之间通信),
 父级组件中:  <List :todos="todos"><template slot-scope="scope"><p>{{scope.row}}</p></template></List>
 父级组件向子级组件传递数据,子级组件内部有<slot> 此时进行占位,父级组件可以使用子级组件传递过来的数据,需要配合template标签及slot-scope,父级组件中可以处理子级组件传递过来的数据,然后进行处理,处理后再次放在子级组件中
组件通信的(高级)方式

  1) 组件间通信高级1: 原生事件/自定义事件/事件总线
  2) 组件间通信高级2: v-model的深入(本质)
  3) 组件间通信高级3: 属性修饰符.sync
  4) 组件间通信高级4: $attrs和$listeners
  5) 组件间通信高级5: $children和$parent
  6) 组件间通信高级6: 作用域插槽

  1) 组件间通信高级1: 原生事件/自定义事件
   原生事件:DOM标签中直接使用系统自带的事件名字及绑定对应的回调函数(该事件触发之后,对应的回调函数会自动的调用并执行),如: click="showMsg1" 点击了,自动触发,回调函数中的代码会自动的执行
   自定义事件:DOM标签中本身没有事件,自己随便定义的事件,但是该事件不会触发(对应的回调函数也不会执行),html标签中(DOM标签)是无法使用自定义事件的,可以使用系统自带的事件(原生事件)
   Vue中所说的自定义事件,一般指的都是在组件标签上使用的事件(该事件没有使用.native进行修饰)
   原生事件:
   <button @click="showMsg1">按钮</button> click就是原生事件,showMsg1会在该事件触发的时候自动的调用执行
   <button @tiana="dia">按钮</button> tiana就是自定义事件,html标签的自定义事件是没有意义的(无法触发)
   Vue中的自定义事件例子,Vue的组件标签上使用
   <Event1 @click="showMsg2" @xxx="showMsg3">  click 就是自定义事件 xxx也是自定义事件,自定义事件是需要手动分发才可以

   讨论的是:html标签上的原生事件和组件标签上的原生事件 以及   组件标签上的自定义事件


   html标签上使用的系统自带的事件,是DOM标签的原生事件,可以自动的分发
   组件标签上使用的事件,如果没有.native修饰,那么是 自定义事件
     组件标签上使用了系统自带的这种事件,但是没有使用.native修饰,那么该事件是自定义事件
     组件标签上使用了自己定义的这种事件,但是没有使用.native修饰,那么该事件是自定义事件

     组件标签上使用了系统自带的这种事件,但是使用了.native修饰,那么该事件是属于原生事件
     组件标签上使用了自己定义的这种事件,但是使用了.native修饰,那么该事件是自定义事件(意义不大)

     组件标签的原生事件,最终绑定到了该组件内部的根标签上了
     组件标签的自定义事件,是不能自动分发的,可以在组件内部通过$emit()手动分发自定义事件,也可以传递数据(实现了父子组件通信)

     组件标签中使用原生事件和自定义事件都可以实现组件之间通信(父子组件之间通信/子父组件之间通信)

   2) 组件间通信高级2: v-model的深入(本质)
    v-model指令是双向数据绑定指令:在表单标签中使用,也可以实现组件之间的通信操作
    v-model指令的本质:实际上是value属性配合input事件,input事件触发之后立刻从事件源对象的value属性中获取数据重新赋值给某个对应的表达式即可

    组件中如果使用了v-model指令,此时内部的子级组件如果和父级组件都能够有v-model指令的效果,首先子级组件内部需要接收父级组件的value属性值,通过子级组件内部的input标签中需要强制绑定value属性,以及该input标签内部需要手动的分发input事件,并且还要把当前子级组件内部的input标签中的value属性的值传递给父级组件

    v-model同样可以实现组件之间通信(父子/子父组件之间通信)

    组件如果使用其他的子级组件,不仅可以使用v-model指令,同时也可以使用:value="" @input="" 的方式实现v-model指令的效果

  3) 组件间通信高级3: 属性修饰符.sync
   如果某个子级组件中要使用父级组件中的数据,首先通过v-bind(:简写)的方式向子级组件传递数据,同时传入到子级组件中一个@update的自定义事件,子级组件内部通过props的方式接收父组件传递进来的数据,同时子级组件内部手动分发update事件,并且把修改后的数据在子级组件中传递给父级组件,向这种方式,我们可以使用.sync修饰符进行简写
   .sync修饰符的本质: 子级组件内部props配合分发update事件来实现的

   应用:
   <Child :age.sync="myAge" /> 该Child组件内部通过props接收了age数据,同时子级组件内部通过$emit()分发了update:age的事件,而且把修改后的数据再次的传递给父级组件

   .sync 修饰符 也可以实现父子组件之间进行通信操作



    4) 组件间通信高级4: $attrs和$listeners

      需求:封装一个高级复用的组件(组件的样式,大小,图标都不一样,包括这个组件的需要用到多少个事件)

    $attrs:在组件(子级组件)中可以通过$attrs这个属性获取父级组件向子级组件传递过来的所有的属性(子级组件中通过props接收过的属性是不算在内的,class和style的属性也不会包含在内),
    $listeners:在组件(子级组件)中可以通过$listeners这个属性获取父级组件向子级组件传递的自定义事件(不包括.native修饰的)
    v-bind指令的使用: 强制数据绑定的指令,有一种更厉害的写法
     v-bind="对象"
    v-on指令的使用: 绑定事件监听的指令,有一种更厉害的写法
     v-on="对象"


     $attrs---->{属性名字1:属性值1,属性名字2:属性值2}
     $listenres---->{事件名字1:回调函数1,事件名字:回调函数2}
     v-bind="对象" 对象是键值对---->属性和值的关系
     v-on="对象"  对象是键值对---->事件名字和回调函数的关系

     $attrs和$listeners实现父子组件之间的通信



     5) 组件间通信高级5: $children和$parent

      $children:是一个属性,可以获取当前这个父级组件中所有的子级组件对象
      $parent:是一个属性,可以获取当前这个子级组件的直接父级组件
      可以实现父子组件之间通信

        混合(混入): 如果一些组件中有相同的选项,那么,可以把这些相同的选项内容的代码放在一个单独的js文件中,并且暴露出去,在这些组件中可以使用mixins的方式来引入混合内容,从而使组件中的代码变的更加的简洁了(减少冗余)


      6) 组件间通信高级6: 作用域插槽
      例子: 父级组件把数组数据传递给了子级组件,但是数组中每个数据的操作,应该由父级组件来进行
      父级组件----->子级组件---->数组----->子级组件遍历数组----->数组中的每个数据------>父级组件来进行处理

      作用域插槽,可以实现父子/子父组件之间相互的通信





  5. 平台属性管理模块
    组件:Card卡片组件/Select下拉框组件/Table表格组件/Button按钮组件/Tag组件/Form表单组件/Popconfirm气泡对话框组件
    三级分类的三个下拉框 这些组件 由于其他组件中也会用到,封装成一个公共的组件,一般都是在components目录中定义这个组件
    由于该组件和当前的商品管理菜单关系很大,所以,可以把这个公共组件放在product目录中定义



*/