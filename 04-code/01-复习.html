<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>玉树临风美少年，揽镜自顾夜不眠 </title>
</head>

<body>
  <script type="text/javascript">


    // 无论是面向过程还是面向对象,都是编程思想(想法)
    // 面向过程: 凡事都是亲力亲为,注重的是过程
    // 自己要煮饭,切菜,洗菜,炒菜,放油,放调料,装盘, 吃饭 ,没有对象,--单身
    // 例子: 我饿了,我要吃饭
    // 封装一个函数,内部实现两个数字的和,调用函数,实现效果----自己写的
    // 面向对象:提出需求,找到对象,注重的是结果
    // 提出需求,我饿了, 找到对象(做饭,炒菜),  吃饭--->结果----有女朋友
    // 例子: 我饿了,我要吃饭
    // 调用对象的计算和的方法,显示结果

    // 对象: 具有特定的属性或者方法,特指的某个事物
    // 观察事物,抽取出对象,找到 特征及行为, 封装成属性和方法,最终通过代码的方式,实现想要的结果

    // JS是什么语言?
    /*
      js是一门解释型语言 ---->遇到一行代码就执行一行代码
      js是一门脚本语言 ----> 不需要编译,直接执行即可
      js是一门弱类型语言--->声明变量都用var
      js是一门动态类型的语言---->不确定当前的变量的类型,执行的时候才能确定类型
      js是一门基于对象的语言---->所有的对象都是基于Object的
      js不是一门纯面向对象的编程语言
      js中是没有类的这个概念的,
      js中没有类的概念.但是js中可以通过构造函数来模拟类,从而实现面向对象的编程思想
      通过观察,抽取对象,分析特征及行为,形成代码,通过代码的方式显示最终的效果,实现面向对象的编程思想的方式进行编程
      先定义类,然后实例化对象,通过对象调用属性及方法,显示效果,但是由于js是一门基于对象的语言,抱歉,没有类的概念,那么就无法定义类这种数据类型,但是,js是可以通过函数的方式来进行类的定义的(所以,通过函数定义类别,该函数称为构造函数)---es6中才出现了class 
      所以,定义类别 通过的是构造函数,实例化对象通过new 构造函数即可

      面向对象的特性:封装,继承,多态
      封装: 把一个值放在变量中,把一些重复的代码放在一个函数中,把很多功能类似的函数放在一个对象中,把很多功能类似的对象放在一个js文件,把一些属性和方法放在一个对象中
      继承: 类与类之间的概念,js中没有类,js中没有继承,但是,js中有构造函数,可以模拟类的概念,通过原型链的方式实现继承
      多态:同一个行为,针对不同的对象产生不同的结果,但是js虽然能够实现多态的效果,几乎不用,也不写,因为更加麻烦,所以,js中可以认为没有多态
      如果这一门语言复合面向对象的特性,则该语言可以称为面向对象的语言,js中没有多态,所以,js不是一门纯面向对象语言
      抽象性: 把你观察到的最终通过代码的方式进行体现
      

      如何实现继承?
      原型； 原型就是对象,js中的原型对象 两个
      prototype: 显示原型,浏览器的标准属性,程序员使用的,构造函数中有
      __proto__: 隐式原型,浏览器的非标准属性,给浏览器使用的,实例对象中

      函数是不是对象?,对象是不是函数?
      只要是函数,内部必然有prototype,只有是对象,内部必然有__proto__


      原型的目的: 共享数据,节省内存空间,实现继承


      继承?-----自己复习

      原型链?----自己复习

      闭包----自己复习

      执行上下文----自己复习

      预解析----自己复习

      递归----自己复习


    
    
    */

    // function Person() { }
    // Person.prototype.sayHi = function () {
    //   console.log('您好')
    // }
    // function Student() { }
    // Student.prototype = new Person()
    // Student.prototype.sayHi = function () {
    //   console.log('我好')
    // }
    // function SmallStudent() { }
    // SmallStudent.prototype.sayHi = function () {
    //   console.log('大家好')
    // }
    // SmallStudent.prototype = new Student()

    // var per = new Person()
    // var stu = new Student()
    // var smStu = new SmallStudent()
    // smStu.sayHi() // 您好  大家好

    // 四件事
    /*

      1. 申请一块空闲的空间
      2. 设置this为的当前实例队形
      3. 初始化属性和方法的值
      4. 返回当前的this

    */
    // function Person(name, age) {
    //   this.name = name;
    //   this.age = age;
    //   // this.sayHi = function () {
    //   //   console.log(this.age)
    //   // };
    // }
    // Person.prototype.sayHi=function(){
    //   console.log(this.age)
    // }
    // var p1 = new Person('小明', 10)
    // var p2 = new Person('小红', 20)

    // // 如果有很多对象,每个对象都有自己的sayHi---->100个对象,100个空间 每个空间都有相同的sayHi的代码
    // console.log(p1.sayHi === p2.sayHi)
    // // 节省空间


    // function f1(){
    //   console.log('哈哈')
    // }

    // console.log(f1);

    // // js代码每行代码结束 必然加分号


    // (function(){
    //   console.log('杨哥好帅哦')
    // })()  // 函数调用

    // vue中几乎不加


    // function f1(){}
    // console.dir(f1)
    // console.dir(Math)

    // 狗
    // function Dog(name,age){
    //   this.name=name;
    //   this.age=age;
    //   this.say=function(){
    //     console.log('汪汪,汪汪汪')
    //   }
    // }

    // // 实例化操作,实例化并初始化
    // var dog = new Dog('大黄',23)
    // dog.say()






    // 面向对象的思想

    // 数组中常用的方法

    // Vue中的基本内容



    // 数组中常用的方法



    // var arr = [10,20,30]
    // // 判断当前的arr是不是一个数组
    // // var result =Array.isArray(arr) 
    // // console.log(result) // 布尔类型
    // // console.log({} instanceof Array)

    // // 自己实现一个判断当前的arr是不是一个数组
    // Array.myIsArray =function(array){
    //   return array instanceof Array
    // }

    // var result = Array.myIsArray(arr)
    // console.log(result)


    // var arr1 = [10, 20, 30]
    // var arr2 = [40, 50, 60]
    // // var result = arr1.concat(arr2)
    // // console.log(result)
    //   // 方法在原型上,最终应该是实例对象调用该方法
    // Array.prototype.myConcat = function (array) {
    //   for (var i = 0; i < array.length; i++) {
    //     this.push(array[i])
    //   }
    //   return this
    // }
    // var result = arr1.myConcat(arr2)
    // console.log(result)


    // var arr = [10, 20, 30, 40, 50, 60,61]
    // 数组的数据是否都是偶数,如果是则返回true,否则返回false
    // var result = arr.every((item,index)=>item%2===0)
    // console.log(result)

    // Array.prototype.myEvery = function (callback) {
    //   for (var i = 0; i < this.length; i++) {
    //     // 
    //     if (!callback(this[i], i)) {
    //       return false
    //     }
    //   }
    //   return true
    // }
    // var result = arr.myEvery((item, index) => item % 2 === 0)
    // console.log(result)

    // 函数的隐式原型指向谁-----> 函数可以是什么




    // function Person(){}

    // var p1 = new Person()
    // var p2 = new Person()
    // var per = new Person()
    // console.dir(per)

    // per 是实例对象不?
    // Person 是对象不?
    // Person对象的实例对象是per


    // 十分钟-----------------把图画出来
    // function F1() { }
    // F1.prototype.eat = function () {
    //   console.log('f1')
    // }
    // function F2() { }
    // F2.prototype = new F1()
    // F2.prototype.eat = function () {
    //   console.log('f2')
    // }
    // function F3() { }
    // F3.prototype = new F2()
    // F3.prototype.eat = function () {
    //   console.log('f3')
    // }
    // var f3 = new F3()
    // f3.eat()
    //   // 结果是什么 为什么  请画出图解
    //   console.log(F1.prototype.__proto__===Object.prototype)
    //   console.log(Object.prototype.__proto__)

    // 原型也是对象
    // 函数中有prototype,对象中有__proto__
    // 函数也是对象,所以,函数中有prototype,也有__proto__
    // 所有的构造函数,都是函数,所有的函数都是Function的实例对象
    // 实例对象的__proto__指向的必然是对应的构造函数的prototype
    // 所有的原型对象,也是实例对象,指向的都是Object的prototype,只有Object的prototype中的__proto__例外

    // function f1() { }
    // console.log(f1.__proto__ === Function.prototype) // 结果
    // console.log(f1.prototype.__proto__ === Object.prototype) // 结果

    // console.log(Function.__proto__ === Function.prototype) // 结果
    // console.log(Function.prototype.__proto__ === Object.prototype) // 结果
    // console.log(Object.__proto__ === Function.prototype) // 结果


    // var obj = new Object() ---必然是构造函数, 函数, 对象, __proto__ Function.prototye
    // console.log(Object instanceof Function)


    // 构造函数
    // function F1(){}
    // // F1 实例对象 是Function 的实例对象
    // var f1 = new F1() 
    // f1 实例对象

    // var obj = new Object()
    // var obj={}
    // obj 实例对象

    // js 浏览器兼容问题 

    // console.log('哈哈') // 原理
    // console 是个对象
    // log 是个方法
    // (参数) 参数有类型 

    // 对象可以调用属性或者方法

    // console.log(typeof console)

    // 冒泡排序  --->3分钟全部敲------->  最高记录 1：30秒----> 初学者

    // var arr = [10, 40, 30, 50, 90, 1]
    // for (var i = 0; i < arr.length - 1; i++) {
    //   for (var j = 0; j < arr.length - 1 - i; j++) {
    //     if (arr[j] < arr[j + 1]) {
    //       var temp = arr[j]
    //       arr[j] = arr[j + 1]
    //       arr[j + 1] = temp
    //     }
    //   }
    // }
    // console.log(arr)

  </script>
</body>

</html>